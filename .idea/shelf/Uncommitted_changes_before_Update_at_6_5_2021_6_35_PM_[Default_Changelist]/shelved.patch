Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Initialization/Initialize.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.Initialization;\r\n\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\npublic class Initialize {\r\n\r\n    public Initialize() {\r\n\r\n    }\r\n\r\n    public Variables Init(HardwareMap hardwareMap) {\r\n        Variables var = new Variables(hardwareMap);\r\n        var.init(var);\r\n\r\n        return var;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Initialization/Initialize.java	(revision 0ebde83e3d44438c311b99956fb6ec418b5c5805)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Initialization/Initialize.java	(date 1622887517766)
@@ -2,16 +2,146 @@
 
 import com.qualcomm.robotcore.hardware.HardwareMap;
 
+import org.firstinspires.ftc.robotcore.external.ClassFactory;
+import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
+
+import java.util.ArrayList;
+
+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;
+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;
+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XZY;
+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;
+
 public class Initialize {
+    private static final float mmPerInch        = 25.4f;
+    private static final float mmTargetHeight   = (6) * mmPerInch;          // the height of the center of the target image above the floor
+
+    private static final float halfField = 72 * mmPerInch;
+    private static final float quadField  = 36 * mmPerInch;
+
+    Variables var;
+
+    WebcamName webcamName = null;
+
+    //Vuforia
+    VuforiaLocalizer vuforia;
+
+    //Tensorflow
+    private static final String TFOD_MODEL_ASSET = "UltimateGoal.tflite";
+    private static final String LABEL_FIRST_ELEMENT = "Quad";
+    private static final String LABEL_SECOND_ELEMENT = "Single";
 
     public Initialize() {
 
     }
 
     public Variables Init(HardwareMap hardwareMap) {
-        Variables var = new Variables(hardwareMap);
+        var = new Variables(hardwareMap);
         var.init(var);
 
+
+        // Vuforia Initialization
+        webcamName = hardwareMap.get(WebcamName.class, "Webcam 1");
+
+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);
+
+        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();
+
+        parameters.vuforiaLicenseKey = "AYSD/P//////AAABmR1zVmwX0kdckb8df7pS1fRsEtj6VXa2Pxmx7PDDfAespnbdYju+FFSuSw6soY6xdrnsS263KCGQQhzpOl7rM8ljS5bqY24sIv1RblWBcEbkVQZ9+F2mAT+75KZBGlmAcss3ccaEj+xjEVftZuiW7CZ/DAgfNUIYdjdWJe8zSB22xS6YRa3nQ4JQ4PopaWI2D/kDF5KghljXKWvdqltKgyVGY3AKhIahUsXAx18hCJt9TExs60MSVQSNQH7tQC9OenKEysMc3481HB56Xaih8TTobKcexXeeZDCVQ6lDfxoaZaVDJir5K5ptLFNIACoDpbgxwgbFJ14JZiAAhOMVZ4pusmWcSSOAdido5x0ZlxT1";
+
+        parameters.cameraName = webcamName;
+
+        // Make sure extended tracking is disabled for this example.
+        parameters.useExtendedTracking = false;
+
+        //  Instantiate the Vuforia engine
+        vuforia = ClassFactory.getInstance().createVuforia(parameters);
+
+        // Load the data sets for the trackable objects. These particular data
+        // sets are stored in the 'assets' part of our application.
+        var.targetsUltimateGoal = vuforia.loadTrackablesFromAsset("UltimateGoal");
+        VuforiaTrackable blueTowerGoalTarget = var.targetsUltimateGoal.get(0);
+        blueTowerGoalTarget.setName("Blue Tower Goal Target");
+        VuforiaTrackable redTowerGoalTarget = var.targetsUltimateGoal.get(1);
+        redTowerGoalTarget.setName("Red Tower Goal Target");
+        VuforiaTrackable redAllianceTarget = var.targetsUltimateGoal.get(2);
+        redAllianceTarget.setName("Red Alliance Target");
+        VuforiaTrackable blueAllianceTarget = var.targetsUltimateGoal.get(3);
+        blueAllianceTarget.setName("Blue Alliance Target");
+        VuforiaTrackable frontWallTarget = var.targetsUltimateGoal.get(4);
+        frontWallTarget.setName("Front Wall Target");
+
+        // For convenience, gather together all the trackable objects in one easily-iterable collection */
+        var.allTrackables = new ArrayList<>(var.targetsUltimateGoal);
+
+
+        //Set the position of the perimeter targets with relation to origin (center of field)
+        redAllianceTarget.setLocation(OpenGLMatrix
+                .translation(0, -halfField, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));
+
+        blueAllianceTarget.setLocation(OpenGLMatrix
+                .translation(0, halfField, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));
+        frontWallTarget.setLocation(OpenGLMatrix
+                .translation(-halfField, 0, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));
+
+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.
+        blueTowerGoalTarget.setLocation(OpenGLMatrix
+                .translation(halfField, quadField, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));
+        redTowerGoalTarget.setLocation(OpenGLMatrix
+                .translation(halfField, -quadField, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));
+
+        final float CAMERA_FORWARD_DISPLACEMENT  = 7.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center
+        final float CAMERA_VERTICAL_DISPLACEMENT = 5.5f * mmPerInch;   // eg: Camera is 8 Inches above ground
+        final float CAMERA_LEFT_DISPLACEMENT     = 0;     // eg: Camera is ON the robot's center line
+
+        OpenGLMatrix cameraLocationOnRobot = OpenGLMatrix
+                .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XZY, DEGREES, 90, 90, 0));
+
+        /*  Let all the trackable listeners know where the phone is.  */
+        for (VuforiaTrackable trackable : var.allTrackables) {
+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(parameters.cameraName, cameraLocationOnRobot);
+        }
+
+
+        // TensorFlow initialization
+
+        initTfod(hardwareMap);
+
+        if (var.tfod != null) {
+            var.tfod.activate();
+
+            // The TensorFlow software will scale the input images from the camera to a lower resolution.
+            // This can result in lower detection accuracy at longer distances (> 55cm or 22").
+            // If your target is at distance greater than 50 cm (20") you can adjust the magnification value
+            // to artificially zoom in to the center of image.  For best results, the "aspectRatio" argument
+            // should be set to the value of the images used to create the TensorFlow Object Detection model
+            // (typically 16/9).
+            var.tfod.setZoom(2.5, 16.0/9.0);
+        }
         return var;
     }
+
+
+
+    private void initTfod(HardwareMap hardwareMap) {
+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(
+                "tfodMonitorViewId", "id", hardwareMap.appContext.getPackageName());
+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);
+        tfodParameters.minResultConfidence = 0.8f;
+        var.tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);
+        var.tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);
+    }
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Initialization/Variables.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.Initialization;\r\n\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\r\nimport org.firstinspires.ftc.teamcode.Resources.RobotHardwareMap;\r\nimport org.firstinspires.ftc.teamcode.Resources.Sensors;\r\nimport org.firstinspires.ftc.teamcode.Resources.Motors;\r\n\r\nimport java.util.Locale;\r\n\r\n@SuppressWarnings(\"unused\")\r\npublic class Variables {\r\n    public RobotHardwareMap robot;\r\n    public Motors motors;\r\n    private boolean OpModeActive = false;\r\n    public Sensors sensors;\r\n    private double heading;\r\n    private double roll;\r\n    private double pitch;\r\n//    Orientation lastAngles;\r\n    public double angle;\r\n    double trueAngle;\r\n    double avgEncoder;\r\n    double distanceL;\r\n    double distanceR;\r\n    double distanceB;\r\n    private Orientation lastAngles;\r\n    private double globalAngle;\r\n\r\n    public Variables(HardwareMap hardware) {\r\n        robot = new RobotHardwareMap(hardware);\r\n        //resetAngle();\r\n    }\r\n\r\n    public void init(Variables var) {\r\n        motors = new Motors(var);\r\n        sensors = new Sensors(var);\r\n       resetAngle();\r\n    }\r\n\r\n//    public double getTrueAngle() {\r\n//        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n//\r\n//        trueAngle = angles.firstAngle;\r\n//        return trueAngle;\r\n//    }\r\n\r\n    public double getAvgEncoder() {\r\n        return avgEncoder;\r\n    }\r\n\r\n    public void setAvgEncoder(double avgEncoder) {\r\n        this.avgEncoder = avgEncoder;\r\n    }\r\n\r\n    public double getDistanceL() {\r\n        return distanceL;\r\n    }\r\n\r\n    public void setDistanceL(double distanceL) {\r\n        this.distanceL = distanceL;\r\n    }\r\n\r\n    public double getDistanceR() {\r\n        return distanceR;\r\n    }\r\n\r\n    public void setDistanceR(double distanceR) {\r\n        this.distanceR = distanceR;\r\n    }\r\n\r\n    public double getDistanceB() {\r\n        return distanceB;\r\n    }\r\n\r\n    public void setDistanceB(double distanceB) {\r\n        this.distanceB = distanceB;\r\n    }\r\n\r\n    public double getDistanceFM() {\r\n        return distanceFM;\r\n    }\r\n\r\n    public void setDistanceFM(double distanceFM) {\r\n        this.distanceFM = distanceFM;\r\n    }\r\n\r\n    double distanceFM;\r\n\r\n    public double getHeading() {\r\n        return heading;\r\n    }\r\n\r\n    public void setHeading(double heading) {\r\n        this.heading = heading;\r\n    }\r\n\r\n    public double getRoll() {\r\n        return roll;\r\n    }\r\n\r\n    public void setRoll(double roll) {\r\n        this.roll = roll;\r\n    }\r\n\r\n    public double getPitch() {\r\n        return pitch;\r\n    }\r\n\r\n    public void setPitch(double pitch) {\r\n        this.pitch = pitch;\r\n    }\r\n\r\n    public void setAngle(double angle) {\r\n        this.angle = angle;\r\n    }\r\n\r\n\r\n    public double getAngle() {\r\n        return sensors.imu();\r\n    }\r\n\r\n    public void resetAngle() {\r\n//        lastAngles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n//\r\n//        globalAngle = 0;\r\n        sensors.resetAngle();\r\n    }\r\n\r\n    public double getTrueAngle() {\r\n        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        trueAngle = Double.parseDouble(formatAngle(angles.angleUnit, angles.firstAngle));\r\n\r\n        return trueAngle;\r\n    }\r\n\r\n    private String formatAngle(AngleUnit angleUnit, double angle) {\r\n        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));\r\n    }\r\n\r\n    private String formatDegrees(double degrees){\r\n        return String.format(Locale.getDefault(), \"%.1f\", AngleUnit.DEGREES.normalize(degrees));\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Initialization/Variables.java	(revision 0ebde83e3d44438c311b99956fb6ec418b5c5805)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Initialization/Variables.java	(date 1622886983616)
@@ -2,14 +2,20 @@
 
 import com.qualcomm.robotcore.hardware.HardwareMap;
 
+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
 import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
 import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
 import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
 import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;
+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
 import org.firstinspires.ftc.teamcode.Resources.RobotHardwareMap;
 import org.firstinspires.ftc.teamcode.Resources.Sensors;
 import org.firstinspires.ftc.teamcode.Resources.Motors;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Locale;
 
 @SuppressWarnings("unused")
@@ -31,6 +37,15 @@
     private Orientation lastAngles;
     private double globalAngle;
 
+    // Vuforia
+    public List<VuforiaTrackable> allTrackables;
+    public OpenGLMatrix lastLocation = null;
+    public VuforiaTrackables targetsUltimateGoal;
+
+    //TensorFlow
+    public TFObjectDetector tfod;
+
+
     public Variables(HardwareMap hardware) {
         robot = new RobotHardwareMap(hardware);
         //resetAngle();
Index: FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetectionWebcam.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2019 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage org.firstinspires.ftc.robotcontroller.external.samples;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport java.util.List;\r\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\r\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\r\n\r\n/**\r\n * This 2020-2021 OpMode illustrates the basics of using the TensorFlow Object Detection API to\r\n * determine the position of the Ultimate Goal game elements.\r\n *\r\n * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\r\n * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list.\r\n *\r\n * IMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as\r\n * is explained below.\r\n */\r\n@TeleOp(name = \"Concept: TensorFlow Object Detection Webcam\", group = \"Concept\")\r\n@Disabled\r\npublic class ConceptTensorFlowObjectDetectionWebcam extends LinearOpMode {\r\n    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\r\n    private static final String LABEL_FIRST_ELEMENT = \"Quad\";\r\n    private static final String LABEL_SECOND_ELEMENT = \"Single\";\r\n\r\n    /*\r\n     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which\r\n     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.\r\n     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer\r\n     * web site at https://developer.vuforia.com/license-manager.\r\n     *\r\n     * Vuforia license keys are always 380 characters long, and look as if they contain mostly\r\n     * random data. As an example, here is a example of a fragment of a valid key:\r\n     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...\r\n     * Once you've obtained a license key, copy the string from the Vuforia web site\r\n     * and paste it in to your code on the next line, between the double quotes.\r\n     */\r\n    private static final String VUFORIA_KEY =\r\n            \" -- YOUR NEW VUFORIA KEY GOES HERE  --- \";\r\n\r\n    /**\r\n     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia\r\n     * localization engine.\r\n     */\r\n    private VuforiaLocalizer vuforia;\r\n\r\n    /**\r\n     * {@link #tfod} is the variable we will use to store our instance of the TensorFlow Object\r\n     * Detection engine.\r\n     */\r\n    private TFObjectDetector tfod;\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\r\n        // first.\r\n        initVuforia();\r\n        initTfod();\r\n\r\n        /**\r\n         * Activate TensorFlow Object Detection before we wait for the start command.\r\n         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\r\n         **/\r\n        if (tfod != null) {\r\n            tfod.activate();\r\n\r\n            // The TensorFlow software will scale the input images from the camera to a lower resolution.\r\n            // This can result in lower detection accuracy at longer distances (> 55cm or 22\").\r\n            // If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\r\n            // to artificially zoom in to the center of image.  For best results, the \"aspectRatio\" argument\r\n            // should be set to the value of the images used to create the TensorFlow Object Detection model\r\n            // (typically 16/9).\r\n            tfod.setZoom(2.5, 16.0/9.0);\r\n        }\r\n\r\n        /** Wait for the game to begin */\r\n        telemetry.addData(\">\", \"Press Play to start op mode\");\r\n        telemetry.update();\r\n        waitForStart();\r\n\r\n        if (opModeIsActive()) {\r\n            while (opModeIsActive()) {\r\n                if (tfod != null) {\r\n                    // getUpdatedRecognitions() will return null if no new information is available since\r\n                    // the last time that call was made.\r\n                    List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\r\n                    if (updatedRecognitions != null) {\r\n                      telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\r\n                      // step through the list of recognitions and display boundary info.\r\n                      int i = 0;\r\n                      for (Recognition recognition : updatedRecognitions) {\r\n                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\r\n                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\r\n                                recognition.getLeft(), recognition.getTop());\r\n                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\r\n                                recognition.getRight(), recognition.getBottom());\r\n                      }\r\n                      telemetry.update();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (tfod != null) {\r\n            tfod.shutdown();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize the Vuforia localization engine.\r\n     */\r\n    private void initVuforia() {\r\n        /*\r\n         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.\r\n         */\r\n        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\r\n\r\n        parameters.vuforiaLicenseKey = VUFORIA_KEY;\r\n        parameters.cameraName = hardwareMap.get(WebcamName.class, \"Webcam 1\");\r\n\r\n        //  Instantiate the Vuforia engine\r\n        vuforia = ClassFactory.getInstance().createVuforia(parameters);\r\n\r\n        // Loading trackables is not necessary for the TensorFlow Object Detection engine.\r\n    }\r\n\r\n    /**\r\n     * Initialize the TensorFlow Object Detection engine.\r\n     */\r\n    private void initTfod() {\r\n        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\r\n            \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\r\n       tfodParameters.minResultConfidence = 0.8f;\r\n       tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\r\n       tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetectionWebcam.java	(revision 0ebde83e3d44438c311b99956fb6ec418b5c5805)
+++ FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetectionWebcam.java	(date 1622885332947)
@@ -50,7 +50,7 @@
  * is explained below.
  */
 @TeleOp(name = "Concept: TensorFlow Object Detection Webcam", group = "Concept")
-@Disabled
+//@Disabled
 public class ConceptTensorFlowObjectDetectionWebcam extends LinearOpMode {
     private static final String TFOD_MODEL_ASSET = "UltimateGoal.tflite";
     private static final String LABEL_FIRST_ELEMENT = "Quad";
@@ -69,7 +69,7 @@
      * and paste it in to your code on the next line, between the double quotes.
      */
     private static final String VUFORIA_KEY =
-            " -- YOUR NEW VUFORIA KEY GOES HERE  --- ";
+            "AYSD/P//////AAABmR1zVmwX0kdckb8df7pS1fRsEtj6VXa2Pxmx7PDDfAespnbdYju+FFSuSw6soY6xdrnsS263KCGQQhzpOl7rM8ljS5bqY24sIv1RblWBcEbkVQZ9+F2mAT+75KZBGlmAcss3ccaEj+xjEVftZuiW7CZ/DAgfNUIYdjdWJe8zSB22xS6YRa3nQ4JQ4PopaWI2D/kDF5KghljXKWvdqltKgyVGY3AKhIahUsXAx18hCJt9TExs60MSVQSNQH7tQC9OenKEysMc3481HB56Xaih8TTobKcexXeeZDCVQ6lDfxoaZaVDJir5K5ptLFNIACoDpbgxwgbFJ14JZiAAhOMVZ4pusmWcSSOAdido5x0ZlxT1";
 
     /**
      * {@link #vuforia} is the variable we will use to store our instance of the Vuforia
@@ -90,7 +90,7 @@
         initVuforia();
         initTfod();
 
-        /**
+        /*
          * Activate TensorFlow Object Detection before we wait for the start command.
          * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.
          **/
@@ -106,7 +106,7 @@
             tfod.setZoom(2.5, 16.0/9.0);
         }
 
-        /** Wait for the game to begin */
+        /* Wait for the game to begin */
         telemetry.addData(">", "Press Play to start op mode");
         telemetry.update();
         waitForStart();
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp/Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.TeleOp;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\n\r\nimport org.firstinspires.ftc.teamcode.Initialization.Variables;\r\nimport org.firstinspires.ftc.teamcode.Initialization.Initialize;\r\nimport org.firstinspires.ftc.teamcode.Resources.Motors;\r\nimport org.firstinspires.ftc.teamcode.Resources.RobotHardwareMap;\r\n\r\n\r\n@TeleOp(name = \"Test\", group = \"TeleOp\")\r\n\r\npublic class Test extends OpMode {\r\n\r\n    Variables var;\r\n    Motors motors;\r\n    RobotHardwareMap robot;\r\n\r\n    DriveTrain driveTrain = DriveTrain.STOP;\r\n    Shooter shooter = Shooter.SHOOTERREST;\r\n\r\n\r\n    private boolean turnFirst = true;\r\n    private boolean begin;\r\n    private boolean begin1;\r\n\r\n    private boolean turning = false;\r\n    private boolean rotationShooter;\r\n    private boolean turningUp;\r\n    private boolean turningDown;\r\n    private boolean turningLeft;\r\n    private boolean turningRight;\r\n    private Shooter curShooterState = Shooter.SHOOTERREST;\r\n    private Shooter prevShooterState = Shooter.SHOOTERREST;\r\n    private DriveTrain curDriveTrainState = DriveTrain.STOP;\r\n    private DriveTrain prevDriveState = DriveTrain.STOP;\r\n\r\n    int Counter= 0;\r\n    boolean shooterLoop = true;\r\n\r\n    @Override\r\n    public void init() {\r\n        var = new Initialize().Init(hardwareMap);\r\n        motors = var.motors;\r\n\r\n        robot = var.robot;\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n\r\n//        if (gamepad1.b) {\r\n//            // right\r\n//            motors.driveStrafe(135 * Math.PI / 180, 1, true);\r\n//        }else if (gamepad1.y) {\r\n//            // forward\r\n//            motors.driveStrafe(45 * Math.PI / 180, 1, true);\r\n//        }else if (gamepad1.x) {\r\n//            // left\r\n//            motors.driveStrafe(-45 * Math.PI / 180, 1, true);\r\n//        }else if (gamepad1.a) {\r\n//            // reverse\r\n//            motors.driveStrafe(-135 * Math.PI / 180, 1, true);\r\n//        }else {\r\n//            motors.driveStrafe(0, 0, false);\r\n//        }\r\n        readInputs();\r\n\r\n\r\n//        readInputs();\r\n\r\n        telemetry.addData(\"Current state\", curShooterState);\r\n\r\n//\r\n//        else if (gamepad1.dpad_up || turningUp)\r\n//            driveTrain = DriveTrain.TURNUP;\r\n//\r\n//        else if (gamepad1.dpad_down || turningDown)\r\n//            driveTrain = DriveTrain.TURNDOWN;\r\n//\r\n//        else if (gamepad1.dpad_left || turningLeft)\r\n//            driveTrain = DriveTrain.TURNLEFT;\r\n//\r\n//        else if (gamepad1.dpad_right || turningRight)\r\n//            driveTrain = DriveTrain.TURNRIGHT;\r\n//\r\n//        if (gamepad1.right_trigger != 0)\r\n//            driveTrain = DriveTrain.STRAFER;\r\n//        else\r\n//        if (gamepad1.left_trigger != 0)\r\n//            driveTrain = DriveTrain.STRAFEL;\r\n//        else\r\n//        if (gamepad1.left_stick_y != 0 || gamepad1.left_stick_x != 0 || gamepad1.right_stick_x != 0)\r\n//            driveTrain = DriveTrain.DRIVE;\r\n//        else\r\n//            driveTrain = DriveTrain.STOP;\r\n\r\n//        stateMachine(driveTrain, shooter);\r\n\r\n//        telemetry.addData(\"State\", driveTrain);\r\n//\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n    }\r\n\r\n    public void readInputs() {\r\n//robot.wobbleLifter.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n//\r\n//if ((gamepad2.b) && curShooterState == Shooter.SHOOTERREST)\r\n//{\r\n//\r\n//    robot.wobbleLifter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//robot.wobbleLifter.setTargetPosition(1000);\r\n//robot.wobbleLifter.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n//\r\n//}\r\n\r\n//        if ((gamepad2.x) && curShooterState == Shooter.SHOOTERREST)\r\n//        {\r\n//            robot.wobbleLifter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//            robot.wobbleLifter.setTargetPosition(1200);\r\n//            robot.wobbleLifter.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n//\r\n//        }\r\n//\r\n//        if ((gamepad2.y) && curShooterState == Shooter.SHOOTERREST)\r\n//        {\r\n//            robot.wobbleLifter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n//            robot.wobbleLifter.setTargetPosition(0);\r\n//            robot.wobbleLifter.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n//\r\n//        }\r\n\r\n        prevDriveState = curDriveTrainState;\r\n//        prevShooterState = curShooterState;\r\n\r\n         if(gamepad2.a &&  curShooterState == Shooter.SHOOTERREST)\r\n\r\n        {\r\n            curShooterState = Shooter.FIRE;\r\n            shooterState(Shooter.FIRE);\r\n\r\n        }\r\n\r\n\r\n        else if(gamepad2.a && curShooterState == Shooter.FIRE)\r\n\r\n        {\r\n\r\n            curShooterState = Shooter.SHOOTERREST;\r\n            shooterState(Shooter.SHOOTERREST);\r\n        }\r\n\r\n        if (gamepad2.b)\r\n        {\r\n\r\n         curShooterState = Shooter.ADJUSTANGLE;\r\n            shooterState(Shooter.ADJUSTANGLE);\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n        if(gamepad2.left_bumper && curShooterState == Shooter.INTAKEREST)\r\n        {\r\n            curShooterState = Shooter.SUCKERIN;\r\n            shooterState(Shooter.SUCKERIN);\r\n        }\r\n\r\n        else if(gamepad2.left_bumper) {\r\n            curShooterState = Shooter.INTAKEREST;\r\n            shooterState(Shooter.INTAKEREST);\r\n        }\r\n\r\n        if(gamepad2.right_bumper && curShooterState == Shooter.INTAKEREST)\r\n        {\r\n            curShooterState = Shooter.SUCKEROUT;\r\n            shooterState(Shooter.SUCKEROUT);\r\n        }\r\n\r\n        else if(gamepad2.right_bumper)\r\n        {\r\n            curShooterState = Shooter.INTAKEREST;\r\n            shooterState(Shooter.INTAKEREST);\r\n        }\r\n\r\n    if ((gamepad1.left_stick_x !=0) || (gamepad1.left_stick_y!=0) || (gamepad1.right_stick_x!=0))\r\n        {\r\n\r\n            curDriveTrainState = DriveTrain.DRIVE;\r\n\r\n        }\r\n\r\n    else if (gamepad1.left_trigger!=0)\r\n\r\n        curDriveTrainState = DriveTrain.STRAFEL;\r\n\r\n    else if (gamepad1.right_trigger!=0)\r\n            curDriveTrainState = DriveTrain.STRAFER;\r\n\r\n    else\r\n        curDriveTrainState = DriveTrain.STOP;\r\n\r\n        driveTrainState(curDriveTrainState, prevDriveState);\r\n// else if ((gamepad1.dpad_up &&  (turnFirst==true))) {\r\n//\r\n//            driveTrainState(DriveTrain.TURNUP);\r\n//        }\r\n//else if ((gamepad1.dpad_left &&  (turnFirst==true)))\r\n//\r\n//    driveTrainState(DriveTrain.TURNLEFT);\r\n//\r\n//else if ((gamepad1.dpad_right &&  (turnFirst==true)))\r\n//\r\n//    driveTrainState(DriveTrain.TURNRIGHT);\r\n//\r\n//else if ((gamepad1.dpad_down &&  (turnFirst==true)))\r\n//\r\n//    driveTrainState(DriveTrain.TURNDOWN);\r\n//\r\n//else {\r\n//    driveTrainState((driveTrain.TURNUP.STOP));\r\n//    driveTrainState((driveTrain.TURNDOWN.STOP));\r\n//    driveTrainState((driveTrain.TURNLEFT.STOP));\r\n//    driveTrainState((driveTrain.TURNRIGHT.STOP));\r\n//\r\n//}\r\n\r\n\r\n//        if (gamepad1.left_trigger!=0)\r\n//        {\r\n//            driveTrainState(DriveTrain.STRAFEL);\r\n//\r\n//        }\r\n//        else  driveTrainState(DriveTrain.STRAFEL.STOP);\r\n//\r\n//\r\n//        if (gamepad1.right_trigger!=0)\r\n//        {\r\n//            driveTrainState(DriveTrain.STRAFER);\r\n//        }\r\n//        else  driveTrainState(DriveTrain.STRAFER.STOP);\r\n    }\r\n\r\n//    private void stateMachine(DriveTrain driveTrain, Shooter shooter) {\r\n//        driveTrainState(driveTrain);\r\n//        shooterState(shooter);\r\n//    }\r\n\r\n    private void driveTrainState(DriveTrain driveTrain, DriveTrain prevState) {\r\n\r\n        switch (driveTrain) {\r\n\r\n            case STRAFEL:\r\n                motors.strafe(-90, gamepad1.left_trigger, begin);\r\n\r\n                if (begin)\r\n                    begin = false;\r\n\r\n                break;\r\n\r\n            case STRAFER:\r\n                motors.strafe(90, gamepad1.right_trigger, begin);\r\n\r\n                if (begin)\r\n                    begin = false;\r\n\r\n                break;\r\n\r\n            case DRIVE:\r\n\r\n                boolean startDrive = prevState != DriveTrain.STOP;\r\n\r\n                telemetry.addData(\"Angle\",motors.mecanum(-gamepad1.left_stick_x, gamepad1.left_stick_y, gamepad1.right_stick_x,startDrive));\r\n                telemetry.addData(\"Angle\", var.getAngle());\r\n//\r\n//                if (begin)\r\n//                    begin = false;\r\n\r\n                break;\r\n\r\n            case TURNUP:\r\n\r\n                if (turnFirst) {\r\n\r\n                    var.resetAngle();\r\n\r\n                    turnFirst = false;\r\n                    motors.pidRotate.reset();\r\n                    motors.pidRotate.enable();\r\n                    turningUp = motors.rotate(0);\r\n                }\r\n\r\n                turningUp = motors.rotate(0);\r\n\r\n\r\n                turnFirst = !turningUp;\r\n\r\n                break;\r\n\r\n            case TURNDOWN:\r\n\r\n                if (turnFirst) {\r\n                    var.resetAngle();\r\n                    turnFirst = false;\r\n                    motors.pidRotate.reset();\r\n                    motors.pidRotate.enable();\r\n                    turningDown = motors.rotate(180);\r\n                }\r\n\r\n                turningDown = motors.rotate(180);\r\n\r\n                turnFirst = !turningDown;\r\n\r\n                break;\r\n\r\n            case TURNLEFT:\r\n\r\n                if (turnFirst) {\r\n                    var.resetAngle();\r\n                    turnFirst = false;\r\n                    motors.pidRotate.reset();\r\n                    motors.pidRotate.enable();\r\n                    turningLeft = motors.rotate(90);\r\n                }\r\n\r\n                turningLeft = motors.rotate(90);\r\n\r\n                turnFirst = !turningLeft;\r\n\r\n                break;\r\n\r\n            case TURNRIGHT:\r\n\r\n                if (turnFirst) {\r\n                    var.resetAngle();\r\n                    turnFirst = false;\r\n                    motors.pidRotate.reset();\r\n                    motors.pidRotate.enable();\r\n                    turningRight = motors.rotate(-90);\r\n                }\r\n\r\n                turningRight = motors.rotate(-90);\r\n\r\n                turnFirst = !turningRight;\r\n\r\n                break;\r\n\r\n            case LEFTTOPOS:\r\n\r\n                motors.LEFTTOPOS(gamepad1.left_bumper);\r\n\r\n                break;\r\n\r\n            case RIGHTTOPOS:\r\n\r\n                motors.RIGHTTOPOS(gamepad1.right_bumper);\r\n\r\n                break;\r\n\r\n            case STOP:\r\n\r\n                motors.stop();\r\n\r\n                begin = true;\r\n\r\n                break;\r\n        }\r\n    }\r\n    private void shooterState(Shooter shooter) {\r\n\r\n        switch (shooter)\r\n\r\n        {\r\n\r\n            case FIRE:\r\n\r\n               robot.shooterMotor.setPower(1);\r\n\r\n                    break;\r\n\r\n            case ADJUSTANGLE:\r\n\r\n                motors.adjustAngle(gamepad2.b);\r\n\r\n                break;\r\n\r\n            case SUCKERIN:\r\n\r\n\r\n                motors.suckerIn(gamepad1.left_bumper);\r\n\r\n\r\n\r\n                break;\r\n\r\n            case SUCKEROUT:\r\n\r\n                motors.suckerOut();\r\n\r\n\r\n                break;\r\n\r\n            case SHOOTERREST:\r\n\r\n                robot.shooterMotor.setPower(0);\r\n                break;\r\n\r\n            case INTAKEREST:\r\n\r\n                motors.intakeStop();\r\n\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp/Test.java	(revision 0ebde83e3d44438c311b99956fb6ec418b5c5805)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp/Test.java	(date 1622887778216)
@@ -1,14 +1,27 @@
 package org.firstinspires.ftc.teamcode.TeleOp;
 
+import android.annotation.SuppressLint;
+
 import com.qualcomm.robotcore.eventloop.opmode.OpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
-import com.qualcomm.robotcore.hardware.DcMotor;
 
+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
+import org.firstinspires.ftc.robotcore.external.matrices.VectorF;
+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
+import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
 import org.firstinspires.ftc.teamcode.Initialization.Variables;
 import org.firstinspires.ftc.teamcode.Initialization.Initialize;
 import org.firstinspires.ftc.teamcode.Resources.Motors;
 import org.firstinspires.ftc.teamcode.Resources.RobotHardwareMap;
 
+import java.util.List;
+
+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;
+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;
+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;
+
 
 @TeleOp(name = "Test", group = "TeleOp")
 
@@ -18,27 +31,22 @@
     Motors motors;
     RobotHardwareMap robot;
 
-    DriveTrain driveTrain = DriveTrain.STOP;
-    Shooter shooter = Shooter.SHOOTERREST;
+//    DriveTrain driveTrain = DriveTrain.STOP;
+//    Shooter shooter = Shooter.SHOOTERREST;
 
 
     private boolean turnFirst = true;
     private boolean begin;
-    private boolean begin1;
+//    private boolean begin1;
 
-    private boolean turning = false;
-    private boolean rotationShooter;
-    private boolean turningUp;
-    private boolean turningDown;
-    private boolean turningLeft;
-    private boolean turningRight;
     private Shooter curShooterState = Shooter.SHOOTERREST;
-    private Shooter prevShooterState = Shooter.SHOOTERREST;
+//    private Shooter prevShooterState = Shooter.SHOOTERREST;
     private DriveTrain curDriveTrainState = DriveTrain.STOP;
-    private DriveTrain prevDriveState = DriveTrain.STOP;
 
-    int Counter= 0;
-    boolean shooterLoop = true;
+//    int Counter= 0;
+//    boolean shooterLoop = true;
+
+    boolean targetVisible = false;
 
     @Override
     public void init() {
@@ -47,10 +55,74 @@
 
         robot = var.robot;
 
+        var.targetsUltimateGoal.activate();
     }
 
+    @SuppressLint("DefaultLocale")
     @Override
     public void loop() {
+//         waitForStart();
+
+        // Note: To use the remote camera preview:
+        // AFTER you hit Init on the Driver Station, use the "options menu" to select "Camera Stream"
+        // Tap the preview window to receive a fresh image.
+
+
+        // check all the trackable targets to see which one (if any) is visible.
+        for (VuforiaTrackable trackable : var.allTrackables) {
+            if (((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible()) {
+                telemetry.addData("Visible Target", trackable.getName());
+                targetVisible = true;
+
+                // getUpdatedRobotLocation() will return null if no new information is available since
+                // the last time that call was made, or if the trackable is not currently visible.
+                OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();
+                if (robotLocationTransform != null) {
+                    var.lastLocation = robotLocationTransform;
+                }
+                break;
+            }
+        }
+
+        // Provide feedback as to where the robot is located (if we know).
+        if (targetVisible) {
+            // express position (translation) of robot in inches.
+            VectorF translation = var.lastLocation.getTranslation();
+            telemetry.addData("Pos (mm)", "{X, Y, Z} = %.1f, %.1f, %.1f",
+                    translation.get(0), translation.get(1), translation.get(2));
+
+            // express the rotation of the robot in degrees.
+            Orientation rotation = Orientation.getOrientation(var.lastLocation, EXTRINSIC, XYZ, DEGREES);
+            telemetry.addData("Rot (deg)", "{Roll, Pitch, Heading} = %.0f, %.0f, %.0f", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);
+        }
+        else {
+            telemetry.addData("Visible Target", "none");
+        }
+
+
+        if (var.tfod != null) {
+            // getUpdatedRecognitions() will return null if no new information is available since
+            // the last time that call was made.
+            List<Recognition> updatedRecognitions = var.tfod.getUpdatedRecognitions();
+            if (updatedRecognitions != null) {
+                telemetry.addData("# Object Detected", updatedRecognitions.size());
+                // step through the list of recognitions and display boundary info.
+                int i = 0;
+                for (Recognition recognition : updatedRecognitions) {
+                    telemetry.addData(String.format("label (%d)", i), recognition.getLabel());
+                    telemetry.addData(String.format("  left,top (%d)", i), "%.03f , %.03f",
+                            recognition.getLeft(), recognition.getTop());
+                    telemetry.addData(String.format("  right,bottom (%d)", i), "%.03f , %.03f",
+                            recognition.getRight(), recognition.getBottom());
+                }
+                telemetry.update();
+            }
+        }
+
+        telemetry.update();
+
+
+        // Disable Tracking when we are done;
 
 //        if (gamepad1.b) {
 //            // right
@@ -72,7 +144,7 @@
 
 //        readInputs();
 
-        telemetry.addData("Current state", curShooterState);
+//        telemetry.addData("Current state", curShooterState);
 
 //
 //        else if (gamepad1.dpad_up || turningUp)
@@ -106,6 +178,11 @@
 
     @Override
     public void stop() {
+        var.targetsUltimateGoal.deactivate();
+
+        if (var.tfod != null) {
+            var.tfod.shutdown();
+        }
     }
 
     public void readInputs() {
@@ -136,7 +213,7 @@
 //
 //        }
 
-        prevDriveState = curDriveTrainState;
+        DriveTrain prevDriveState = curDriveTrainState;
 //        prevShooterState = curShooterState;
 
          if(gamepad2.a &&  curShooterState == Shooter.SHOOTERREST)
@@ -287,6 +364,7 @@
 
             case TURNUP:
 
+                boolean turningUp;
                 if (turnFirst) {
 
                     var.resetAngle();
@@ -294,7 +372,6 @@
                     turnFirst = false;
                     motors.pidRotate.reset();
                     motors.pidRotate.enable();
-                    turningUp = motors.rotate(0);
                 }
 
                 turningUp = motors.rotate(0);
@@ -306,12 +383,12 @@
 
             case TURNDOWN:
 
+                boolean turningDown;
                 if (turnFirst) {
                     var.resetAngle();
                     turnFirst = false;
                     motors.pidRotate.reset();
                     motors.pidRotate.enable();
-                    turningDown = motors.rotate(180);
                 }
 
                 turningDown = motors.rotate(180);
@@ -322,12 +399,12 @@
 
             case TURNLEFT:
 
+                boolean turningLeft;
                 if (turnFirst) {
                     var.resetAngle();
                     turnFirst = false;
                     motors.pidRotate.reset();
                     motors.pidRotate.enable();
-                    turningLeft = motors.rotate(90);
                 }
 
                 turningLeft = motors.rotate(90);
@@ -338,12 +415,12 @@
 
             case TURNRIGHT:
 
+                boolean turningRight;
                 if (turnFirst) {
                     var.resetAngle();
                     turnFirst = false;
                     motors.pidRotate.reset();
                     motors.pidRotate.enable();
-                    turningRight = motors.rotate(-90);
                 }
 
                 turningRight = motors.rotate(-90);
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Resources/Vuforia.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Resources/Vuforia.java	(date 1622883387868)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Resources/Vuforia.java	(date 1622883387868)
@@ -0,0 +1,172 @@
+
+package org.firstinspires.ftc.teamcode.Resources;
+
+import com.qualcomm.robotcore.eventloop.opmode.Disabled;
+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
+
+import org.firstinspires.ftc.robotcore.external.ClassFactory;
+import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
+import org.firstinspires.ftc.robotcore.external.matrices.VectorF;
+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.firstinspires.ftc.robotcore.external.navigation.AngleUnit.DEGREES;
+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XYZ;
+import static org.firstinspires.ftc.robotcore.external.navigation.AxesOrder.XZY;
+import static org.firstinspires.ftc.robotcore.external.navigation.AxesReference.EXTRINSIC;
+
+
+
+@TeleOp(name="ULTIMATEGOAL Vuforia Nav Webcam", group ="Concept")
+@Disabled
+public class Vuforia extends LinearOpMode {
+
+//    private static final String VUFORIA_KEY =
+//            " --- YOUR NEW VUFORIA KEY GOES HERE  --- ";
+    private static final float mmPerInch        = 25.4f;
+    private static final float mmTargetHeight   = (6) * mmPerInch;          // the height of the center of the target image above the floor
+
+    private static final float halfField = 72 * mmPerInch;
+    private static final float quadField  = 36 * mmPerInch;
+
+    private OpenGLMatrix lastLocation = null;
+    private VuforiaLocalizer vuforia = null;
+
+    WebcamName webcamName = null;
+
+    private boolean targetVisible = false;
+    private float phoneXRotate    = 0;
+    private float phoneYRotate    = 0;
+    private float phoneZRotate    = 0;
+
+    @Override public void runOpMode() {
+
+        webcamName = hardwareMap.get(WebcamName.class, "Webcam 1");
+
+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);
+
+        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();
+
+        parameters.vuforiaLicenseKey = " --- YOUR NEW VUFORIA KEY GOES HERE  --- ";
+
+        parameters.cameraName = webcamName;
+
+        // Make sure extended tracking is disabled for this example.
+        parameters.useExtendedTracking = false;
+
+        //  Instantiate the Vuforia engine
+        vuforia = ClassFactory.getInstance().createVuforia(parameters);
+
+        // Load the data sets for the trackable objects. These particular data
+        // sets are stored in the 'assets' part of our application.
+        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset("UltimateGoal");
+        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);
+        blueTowerGoalTarget.setName("Blue Tower Goal Target");
+        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);
+        redTowerGoalTarget.setName("Red Tower Goal Target");
+        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);
+        redAllianceTarget.setName("Red Alliance Target");
+        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);
+        blueAllianceTarget.setName("Blue Alliance Target");
+        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);
+        frontWallTarget.setName("Front Wall Target");
+
+        // For convenience, gather together all the trackable objects in one easily-iterable collection */
+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>(targetsUltimateGoal);
+
+
+        //Set the position of the perimeter targets with relation to origin (center of field)
+        redAllianceTarget.setLocation(OpenGLMatrix
+                .translation(0, -halfField, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));
+
+        blueAllianceTarget.setLocation(OpenGLMatrix
+                .translation(0, halfField, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));
+        frontWallTarget.setLocation(OpenGLMatrix
+                .translation(-halfField, 0, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));
+
+        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.
+        blueTowerGoalTarget.setLocation(OpenGLMatrix
+                .translation(halfField, quadField, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));
+        redTowerGoalTarget.setLocation(OpenGLMatrix
+                .translation(halfField, -quadField, mmTargetHeight)
+                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));
+
+        final float CAMERA_FORWARD_DISPLACEMENT  = 7.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center
+        final float CAMERA_VERTICAL_DISPLACEMENT = 5.5f * mmPerInch;   // eg: Camera is 8 Inches above ground
+        final float CAMERA_LEFT_DISPLACEMENT     = 0;     // eg: Camera is ON the robot's center line
+
+        OpenGLMatrix cameraLocationOnRobot = OpenGLMatrix
+                    .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)
+                    .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XZY, DEGREES, 90, 90, 0));
+
+        /*  Let all the trackable listeners know where the phone is.  */
+        for (VuforiaTrackable trackable : allTrackables) {
+            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(parameters.cameraName, cameraLocationOnRobot);
+        }
+
+        // WARNING:
+        // In this sample, we do not wait for PLAY to be pressed.  Target Tracking is started immediately when INIT is pressed.
+        // This sequence is used to enable the new remote DS Camera Preview feature to be used with this sample.
+        // CONSEQUENTLY do not put any driving commands in this loop.
+        // To restore the normal opmode structure, just un-comment the following line:
+
+//         waitForStart();
+
+        // Note: To use the remote camera preview:
+        // AFTER you hit Init on the Driver Station, use the "options menu" to select "Camera Stream"
+        // Tap the preview window to receive a fresh image.
+
+        targetsUltimateGoal.activate();
+        while (!isStopRequested()) {
+
+            // check all the trackable targets to see which one (if any) is visible.
+            targetVisible = false;
+            for (VuforiaTrackable trackable : allTrackables) {
+                if (((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible()) {
+                    telemetry.addData("Visible Target", trackable.getName());
+                    targetVisible = true;
+
+                    // getUpdatedRobotLocation() will return null if no new information is available since
+                    // the last time that call was made, or if the trackable is not currently visible.
+                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();
+                    if (robotLocationTransform != null) {
+                        lastLocation = robotLocationTransform;
+                    }
+                    break;
+                }
+            }
+
+            // Provide feedback as to where the robot is located (if we know).
+            if (targetVisible) {
+                // express position (translation) of robot in inches.
+                VectorF translation = lastLocation.getTranslation();
+                telemetry.addData("Pos (mm)", "{X, Y, Z} = %.1f, %.1f, %.1f",
+                        translation.get(0), translation.get(1), translation.get(2));
+
+                // express the rotation of the robot in degrees.
+                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);
+                telemetry.addData("Rot (deg)", "{Roll, Pitch, Heading} = %.0f, %.0f, %.0f", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);
+            }
+            else {
+                telemetry.addData("Visible Target", "none");
+            }
+            telemetry.update();
+        }
+
+        // Disable Tracking when we are done;
+        targetsUltimateGoal.deactivate();
+    }
+}
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" default=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/build/classes\" />\r\n  </component>\r\n  <component name=\"ProjectType\">\r\n    <option name=\"id\" value=\"Android\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision 0ebde83e3d44438c311b99956fb6ec418b5c5805)
+++ .idea/misc.xml	(date 1622887588582)
@@ -1,5 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="EntryPointsManager">
+    <list size="1">
+      <item index="0" class="java.lang.String" itemvalue="com.qualcomm.robotcore.eventloop.opmode.TeleOp" />
+    </list>
+  </component>
   <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
